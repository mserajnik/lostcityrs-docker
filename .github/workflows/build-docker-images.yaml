name: Build and push Docker images

on:
  # Build images daily
  schedule:
    - cron: 0 0 * * *
  push:
    branches:
      - master
    paths:
      - Dockerfile
      - docker-cmd-start.sh
  pull_request:
    branches:
      - master
    paths:
      - Dockerfile
      - docker-cmd-start.sh
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/lostcityrs
  OCI_ANNOTATION_AUTHORS: ${{ vars.OCI_ANNOTATION_AUTHORS || github.repository_owner }}
  OCI_ANNOTATION_URL: https://github.com/${{ github.repository }}
  OCI_ANNOTATION_DOCUMENTATION: https://github.com/${{ github.repository }}/blob/master/README.md
  OCI_ANNOTATION_SOURCE: https://github.com/${{ github.repository }}
  OCI_ANNOTATION_VENDOR: ${{ vars.OCI_ANNOTATION_VENDOR || github.repository_owner }}
  OCI_ANNOTATION_LICENSES: MIT
  OCI_ANNOTATION_TITLE: Lost City RS
  OCI_ANNOTATION_DESCRIPTION: Lost City RS is a server emulator for RS2.
  OCI_ANNOTATION_BASE_NAME: bun:debian

jobs:
  build-and-push-images:
    name: Build and push images
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: true
      matrix:
        version: [245.2, 244, 225]
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate timestamp
        id: generate-timestamp
        run: echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      # We tag the newest build for version 245.2 with `latest` since that can
      # be considered the default right now.
      - name: Generate tags
        uses: actions/github-script@v8
        id: generate-tags
        env:
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          VERSION: ${{ matrix.version }}
        with:
          result-encoding: string
          script: |
            const tags = []

            if (process.env.VERSION === '245.2') {
              tags.push(`${process.env.IMAGE}:latest`)
            }

            tags.push(`${process.env.IMAGE}:${process.env.VERSION}`)

            return tags.join(',')

      # See https://github.com/opencontainers/image-spec/blob/main/annotations.md
      - name: Generate OCI annotations
        uses: actions/github-script@v8
        id: generate-annotations
        env:
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          VERSION: ${{ matrix.version }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const annotations = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'VERSION' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.VERSION}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                return [
                  `manifest:org.opencontainers.image.${key}=${resolvedValue}`,
                  `index:org.opencontainers.image.${key}=${resolvedValue}`,
                ]
              })
              .flat()
              .join('\n')

            return annotations

      # We also add the generated OCI metadata as labels because the GitHub
      # Container registry does not correctly pick up the OCI annotations in
      # some cases and prefers to pull displayed data from the image labels
      # instead (which then results in data from the base images being shown if
      # we do not provide values for the respective labels ourselves).
      - name: Generate OCI labels
        uses: actions/github-script@v8
        id: generate-labels
        env:
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          VERSION: ${{ matrix.version }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const labels = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'VERSION' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.VERSION}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                return `org.opencontainers.image.${key}=${resolvedValue}`
              })
              .join('\n')

            return labels

      - name: Build and push images
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64, linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          provenance: false
          build-args: |
            LOST_CITY_RS_VERSION=${{ matrix.version }}
          tags: ${{ steps.generate-tags.outputs.result }}
          annotations: ${{ steps.generate-annotations.outputs.result }}
          labels: ${{ steps.generate-labels.outputs.result }}

  delete-old-package-versions:
    name: Delete old package versions
    needs: [build-and-push-images]
    if: ${{ github.event_name != 'pull_request' }}
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: write

    steps:
      - name: Delete old package versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: lostcityrs
          package-type: container
          # According to
          # https://docs.github.com/en/enterprise-server@3.11/packages/working-with-a-github-packages-registry/working-with-the-npm-registry#limits-for-published-npm-versions
          # there might at some point be a limit of 1,000 versions per package.
          # It is not clear if that will only be applied to Enterprise and/or
          # npm packages, but let's be safe and make sure we don't keep more
          # than 1,000.
          #
          # We have 3 different versions per build. For each version, we have
          # the image index plus two image manifests, making a total of 9
          # packages.
          #
          # This means, to stay below the assumed limit of 1,000 packages, we
          # can keep a maximum of 111 builds worth of server images; let's make
          # that 100 to have a nice and round number:
          # 9 * 100 = 900 packages
          min-versions-to-keep: 900
