name: Build and push Docker images

on:
  # Build images daily
  schedule:
    - cron: 0 0 * * *
  push:
    branches:
      - master
    paths:
      - Dockerfile
      - docker-cmd-start.sh
  pull_request:
    branches:
      - master
    paths:
      - Dockerfile
      - docker-cmd-start.sh
  workflow_dispatch:
    inputs:
      force-rebuild:
        type: boolean
        description: Force rebuild (even if images for the latest commit hashes already exist)
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/lostcityrs
  OCI_ANNOTATION_AUTHORS: ${{ vars.OCI_ANNOTATION_AUTHORS || github.repository_owner }}
  OCI_ANNOTATION_URL: https://github.com/${{ github.repository }}
  OCI_ANNOTATION_DOCUMENTATION: https://github.com/${{ github.repository }}/blob/master/README.md
  OCI_ANNOTATION_SOURCE: https://github.com/${{ github.repository }}
  OCI_ANNOTATION_VENDOR: ${{ vars.OCI_ANNOTATION_VENDOR || github.repository_owner }}
  OCI_ANNOTATION_LICENSES: MIT
  OCI_ANNOTATION_TITLE: Lost City RS
  OCI_ANNOTATION_DESCRIPTION: Lost City RS is a server emulator for RS2.
  OCI_ANNOTATION_BASE_NAME: bun:debian

jobs:
  build-and-push-images:
    name: Build and push images
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: true
      matrix:
        version: [245.2, 244, 225]
    permissions:
      contents: read
      packages: write

    steps:
      - name: Get latest engine commit hash for version
        uses: actions/github-script@v8
        id: latest-engine-commit-hash
        env:
          VERSION: ${{ matrix.version }}
        with:
          result-encoding: string
          retries: 3
          script: |
            const ref = await github.rest.git.getRef({
              owner: 'LostCityRS',
              repo: 'Engine-TS',
              ref: `heads/${process.env.VERSION}`,
            })

            return ref.data.object.sha

      - name: Get latest content commit hash for version
        uses: actions/github-script@v8
        id: latest-content-commit-hash
        env:
          VERSION: ${{ matrix.version }}
        with:
          result-encoding: string
          retries: 3
          script: |
            const ref = await github.rest.git.getRef({
              owner: 'LostCityRS',
              repo: 'Content',
              ref: `heads/${process.env.VERSION}`,
            })

            return ref.data.object.sha

      - name: Generate combined commit hashes tag
        uses: actions/github-script@v8
        id: combined-commit-hashes-tag
        env:
          ENGINE_COMMIT_HASH: ${{ steps.latest-engine-commit-hash.outputs.result }}
          CONTENT_COMMIT_HASH: ${{ steps.latest-content-commit-hash.outputs.result }}
          VERSION: ${{ matrix.version }}
        with:
          result-encoding: string
          script: |
            return `${process.env.VERSION}-engine.${process.env.ENGINE_COMMIT_HASH.substring(0, 7)}-content.${process.env.CONTENT_COMMIT_HASH.substring(0, 7)}`

      # We check if the workflow was triggered by a schedule and if today is
      # Monday, in which case we want to trigger a (re)build in any case (to
      # keep the Docker images up-to-date).
      #
      # We also check if the "force rebuild" input is checked when the workflow
      # is triggered manually; if yes, we also want to (re)build.
      - name: Determine if images for commit hashes already exist
        id: images-already-exist
        run: |
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            if [[ "$(date +%u)" -eq 1 ]]; then
              echo "result=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          if [[ "${{ inputs.force-rebuild }}" == "true" ]]; then
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          ghcr_token=$(echo ${{ secrets.GITHUB_TOKEN }} | base64)
          tags=$(skopeo list-tags --registry-token ${ghcr_token} docker://${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} | jq '.Tags[]')

          if grep -q "${{ steps.combined-commit-hashes-tag.outputs.result }}" <<< "${tags}"; then
            echo "result=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "result=false" >> $GITHUB_OUTPUT

      - name: Checkout repository
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        uses: actions/checkout@v5

      - name: Set up QEMU
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Log in to container registry
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate timestamp
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        id: generate-timestamp
        run: echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      # We tag the newest build for version 245.2 with `latest` since that can
      # be considered the default right now.
      - name: Generate tags
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        uses: actions/github-script@v8
        id: generate-tags
        env:
          COMMIT_HASHES_TAG: ${{ steps.combined-commit-hashes-tag.outputs.result }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          VERSION: ${{ matrix.version }}
        with:
          result-encoding: string
          script: |
            const tags = []

            if (process.env.VERSION === '245.2') {
              tags.push(`${process.env.IMAGE}:latest`)
            }

            tags.push(`${process.env.IMAGE}:${process.env.VERSION}`)
            tags.push(`${process.env.IMAGE}:${process.env.COMMIT_HASHES_TAG}`)

            return tags.join(',')

      # See https://github.com/opencontainers/image-spec/blob/main/annotations.md
      - name: Generate OCI annotations
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        uses: actions/github-script@v8
        id: generate-annotations
        env:
          ENGINE_COMMIT_HASH: ${{ steps.latest-engine-commit-hash.outputs.result }}
          COMMIT_HASHES_TAG: ${{ steps.combined-commit-hashes-tag.outputs.result }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          VERSION: ${{ matrix.version }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const annotations = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'VERSION' },
              { key: 'revision', envKey: 'ENGINE_COMMIT_HASH' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.COMMIT_HASHES_TAG}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                return [
                  `manifest:org.opencontainers.image.${key}=${resolvedValue}`,
                  `index:org.opencontainers.image.${key}=${resolvedValue}`,
                ]
              })
              .flat()
              .join('\n')

            return annotations

      # We also add the generated OCI metadata as labels because the GitHub
      # Container registry does not correctly pick up the OCI annotations in
      # some cases and prefers to pull displayed data from the image labels
      # instead (which then results in data from the base images being shown if
      # we do not provide values for the respective labels ourselves).
      - name: Generate OCI labels
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        uses: actions/github-script@v8
        id: generate-labels
        env:
          ENGINE_COMMIT_HASH: ${{ steps.latest-engine-commit-hash.outputs.result }}
          COMMIT_HASHES_TAG: ${{ steps.combined-commit-hashes-tag.outputs.result }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          VERSION: ${{ matrix.version }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const labels = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'VERSION' },
              { key: 'revision', envKey: 'ENGINE_COMMIT_HASH' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.COMMIT_HASHES_TAG}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                return `org.opencontainers.image.${key}=${resolvedValue}`
              })
              .join('\n')

            return labels

      - name: Build and push images
        if: ${{ steps.images-already-exist.outputs.result != 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64, linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          provenance: false
          build-args: |
            LOST_CITY_RS_VERSION=${{ matrix.version }}
          tags: ${{ steps.generate-tags.outputs.result }}
          annotations: ${{ steps.generate-annotations.outputs.result }}
          labels: ${{ steps.generate-labels.outputs.result }}

  delete-old-package-versions:
    name: Delete old package versions
    needs: [build-and-push-images]
    if: ${{ github.event_name != 'pull_request' }}
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: write

    steps:
      - name: Delete old package versions
        uses: actions/delete-package-versions@v5
        with:
          package-name: lostcityrs
          package-type: container
          # According to
          # https://docs.github.com/en/enterprise-server@3.11/packages/working-with-a-github-packages-registry/working-with-the-npm-registry#limits-for-published-npm-versions
          # there might at some point be a limit of 1,000 versions per package.
          # It is not clear if that will only be applied to Enterprise and/or
          # npm packages, but let's be safe and make sure we don't keep more
          # than 1,000.
          #
          # We have 3 different versions per build. For each version, we have
          # the image index plus two image manifests, making a total of 9
          # packages.
          #
          # This means, to stay below the assumed limit of 1,000 packages, we
          # can keep a maximum of 111 builds worth of server images; let's make
          # that 100 to have a nice and round number:
          # 9 * 100 = 900 packages
          min-versions-to-keep: 900
